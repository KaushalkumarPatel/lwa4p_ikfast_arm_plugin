/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2020-01-22 15:57:39.658437
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[2]);
x3=IKcos(j[2]);
x4=IKsin(j[1]);
x5=IKsin(j[0]);
x6=IKsin(j[3]);
x7=IKcos(j[3]);
x8=IKcos(j[5]);
x9=IKsin(j[5]);
x10=IKcos(j[4]);
x11=IKsin(j[4]);
x12=((1.0e-8)*x0);
x13=((0.005263)*x5);
x14=((1.0)*x5);
x15=((1.0)*x0);
x16=((0.305)*x0);
x17=((1.0)*x11);
x18=((1.0e-8)*x5);
x19=((1.0)*x10);
x20=((0.305)*x5);
x21=((0.005263)*x0);
x22=((0.35)*x4);
x23=(x1*x2);
x24=(x1*x3);
x25=(x3*x4);
x26=(x2*x4);
x27=(x14*x6);
x28=((1.0)*x25);
x29=((((-1.0)*x28))+x23);
x30=((((-1.0)*x23))+x28);
x31=((((1.0)*x24))+(((1.0)*x26)));
x32=(x30*x6);
x33=(x10*x29*x7);
x34=(x15*(((((-1.0)*x25))+x23)));
x35=(x14*(((((-1.0)*x25))+x23)));
x36=(x15*((x24+x26)));
x37=(x14*((x24+x26)));
x38=(x11*x35);
x39=(x37*x7);
x40=(x36*x7);
x41=(((x5*x7))+((x36*x6)));
x42=((((-1.0)*x15*x7))+((x37*x6)));
x43=((((-1.0)*x40))+x27);
x44=((((-1.0)*x39))+(((-1.0)*x15*x6)));
x45=(x10*x43);
eerot[0]=(((x41*x9))+((x8*((((x11*x34))+x45)))));
eerot[1]=(((x41*x8))+((x9*(((((-1.0)*x17*x34))+(((-1.0)*x19*x43)))))));
eerot[2]=(((x10*x34))+((x11*(((((-1.0)*x27))+x40)))));
IkReal x46=((1.0)*x21);
eetrans[0]=(((x6*(((((-1.0)*x26*x46))+(((-1.0)*x24*x46))))))+(((-1.0)*x18*x6))+(((-1.0)*x0*x22))+(((-1.0)*x16*x25))+((x7*((((x12*x24))+((x12*x26))))))+((x16*x23))+(((-1.0)*x13*x7)));
eerot[3]=(((x42*x9))+((x8*((((x10*x44))+x38)))));
eerot[4]=(((x42*x8))+((x9*(((((-1.0)*x17*x35))+(((-1.0)*x19*x44)))))));
eerot[5]=(((x11*((((x0*x6))+x39))))+((x10*x35)));
IkReal x47=((1.0)*x13);
eetrans[1]=(((x21*x7))+((x6*(((((-1.0)*x26*x47))+(((-1.0)*x24*x47))))))+(((-1.0)*x22*x5))+((x12*x6))+((x7*((((x18*x26))+((x18*x24))))))+((x20*x23))+(((-1.0)*x20*x25)));
eerot[6]=(((x32*x9))+((x8*((((x11*x31))+x33)))));
eerot[7]=(((x32*x8))+((x9*(((((-1.0)*x17*x31))+(((-1.0)*x19*x29*x7)))))));
eerot[8]=(((x10*x31))+((x11*x30*x7)));
eetrans[2]=((((0.35)*x1))+((x6*(((((0.005263)*x23))+(((-0.005263)*x25))))))+((x7*(((((-1.0e-8)*x23))+(((1.0e-8)*x25))))))+(((0.305)*x26))+(((0.305)*x24)));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=r00;
new_r01=r01;
new_r02=r02;
new_px=px;
new_r10=r10;
new_r11=r11;
new_r12=r12;
new_py=py;
new_r20=r20;
new_r21=r21;
new_r22=r22;
new_pz=pz;
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x48=((1.0)*px);
IkReal x49=((1.0)*pz);
IkReal x50=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x50))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x49)));
rxp0_2=((((-1.0)*r10*x48))+((py*r00)));
rxp1_0=((((-1.0)*r21*x50))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x49)));
rxp1_2=((((-1.0)*r11*x48))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x50)));
rxp2_1=((((-1.0)*r02*x49))+((px*r22)));
rxp2_2=((((-1.0)*r12*x48))+((py*r02)));
IkReal op[72], zeror[48];
int numroots;;
IkReal x51=((7.0)*r01);
IkReal x52=((3210430.0)*r11);
IkReal x53=((20.0)*rxp1_1);
IkReal x54=((610000000.0)*py);
IkReal x55=((7.0)*r21);
IkReal x56=((20.0)*npy);
IkReal x57=((40.0)*npx);
IkReal x58=((14.0)*r20);
IkReal x59=((14.0)*r00);
IkReal x60=((6420860.0)*r10);
IkReal x61=((40.0)*rxp0_1);
IkReal x62=((0.07544344470915)*rxp1_1);
IkReal x63=((314349.936370924)*py);
IkReal x64=((0.001289435)*px);
IkReal x65=((1654.42371512017)*r11);
IkReal x66=((0.001289435)*pz);
IkReal x67=((0.01030655529085)*npy);
IkReal x68=((0.0206131105816999)*npx);
IkReal x69=((3308.84743024035)*r10);
IkReal x70=((0.1508868894183)*rxp0_1);
IkReal x71=((14.0)*r11);
IkReal x72=((1220000000.0)*px);
IkReal x73=((6420860.0)*r01);
IkReal x74=((40.0)*rxp1_0);
IkReal x75=((28.0)*r10);
IkReal x76=((12841720.0)*r00);
IkReal x77=((80.0)*rxp0_0);
IkReal x78=((0.00257887)*py);
IkReal x79=((3308.84743024035)*r01);
IkReal x80=((628699.872741848)*px);
IkReal x81=((0.1508868894183)*rxp1_0);
IkReal x82=((0.3017737788366)*rxp0_0);
IkReal x83=((6617.69486048069)*r00);
IkReal x84=((0.49)*npx);
IkReal x85=((0.1225)*pp);
IkReal x86=((0.245)*npy);
IkReal x87=((0.245)*pp);
IkReal x88=(r01*x85);
IkReal x89=(px*x86);
IkReal x90=(r21*x85);
IkReal x91=(pz*x86);
IkReal x92=(pz*x84);
IkReal x93=(r20*x87);
IkReal x94=(r00*x87);
IkReal x95=(px*x84);
IkReal x96=(r11*x87);
IkReal x97=((0.49)*npy*py);
IkReal x98=((0.49)*pp*r10);
IkReal x99=((0.98)*npx*py);
IkReal x100=(x57+(((-1.0)*x58)));
IkReal x101=((5.42434004957434e-5)+x66);
IkReal x102=((-5.42434004957434e-5)+x66);
IkReal x103=((-0.10526)+(((-1.0)*x56))+(((-1.0)*x55)));
IkReal x104=((((-1.0)*x58))+(((-1.0)*x57)));
IkReal x105=((0.10526)+x56+(((-1.0)*x55)));
IkReal x106=(x60+x61);
IkReal x107=((0.10526)+x55+(((-1.0)*x56)));
IkReal x108=(x54+x51);
IkReal x109=(x53+x52);
IkReal x110=(x79+x78);
IkReal x111=(x55+x56);
IkReal x112=(x77+x76);
IkReal x113=(x74+x73);
IkReal x114=(x78+x81);
IkReal x115=(x63+x64);
IkReal x116=((-0.10526)+x111);
IkReal x117=(x62+x88);
IkReal x118=(x70+x94);
IkReal x119=(x69+x95);
IkReal x120=(x65+x89);
IkReal x121=(x70+x95);
IkReal x122=(x69+x94);
IkReal x123=(x80+x97);
IkReal x124=(x80+x96);
IkReal x125=(x67+x91);
IkReal x126=(x65+x88);
IkReal x127=(x67+x90);
IkReal x128=(x62+x89);
IkReal x129=(x106+x59);
IkReal x130=(x109+x51);
IkReal x131=(x109+x54);
IkReal x132=(x113+x72);
IkReal x133=(x68+x92+(((-1.0)*x93)));
IkReal x134=(x128+x64);
IkReal x135=(x126+x63);
IkReal x136=(x92+(((-1.0)*x93))+(((-1.0)*x68)));
IkReal x137=(x126+x64);
IkReal x138=(x128+x63);
IkReal x139=(x108+x109);
IkReal x140=(x120+x115);
IkReal x141=(x117+x115);
IkReal x142=(x125+x101+(((-1.0)*x90)));
IkReal x143=((((-1.0)*x125))+x101+x90);
IkReal x144=((((-1.0)*x127))+x102+x91);
IkReal x145=(x127+x102+(((-1.0)*x91)));
op[0]=((-1.0)*x139);
op[1]=x103;
op[2]=((-1.0)*x129);
op[3]=x104;
op[4]=(x130+(((-1.0)*x54)));
op[5]=x116;
op[6]=x105;
op[7]=((((-1.0)*x131))+x51);
op[8]=x100;
op[9]=((((-1.0)*x106))+x59);
op[10]=x107;
op[11]=((((-1.0)*x108))+x109);
op[12]=((((-1.0)*x117))+x140);
op[13]=x142;
op[14]=((((-1.0)*x118))+x119);
op[15]=x133;
op[16]=((((-1.0)*x120))+x141);
op[17]=x143;
op[18]=x144;
op[19]=(x135+(((-1.0)*x134)));
op[20]=x136;
op[21]=((((-1.0)*x121))+x122);
op[22]=x145;
op[23]=(x138+(((-1.0)*x137)));
op[24]=((((-1.0)*x71))+x132);
op[25]=0;
op[26]=((((-1.0)*x75))+x112);
op[27]=0;
op[28]=((((-1.0)*x113))+x72+x71);
op[29]=0;
op[30]=0;
op[31]=(x132+x71);
op[32]=0;
op[33]=(x112+x75);
op[34]=0;
op[35]=((((-1.0)*x71))+(((-1.0)*x113))+x72);
op[36]=((((-1.0)*x79))+(((-1.0)*x124))+x114+x97);
op[37]=0;
op[38]=(x82+x99+(((-1.0)*x98))+(((-1.0)*x83)));
op[39]=0;
op[40]=((((-1.0)*x123))+x110+x96+(((-1.0)*x81)));
op[41]=0;
op[42]=0;
op[43]=((((-1.0)*x110))+(((-1.0)*x123))+x81+x96);
op[44]=0;
op[45]=(x82+x98+(((-1.0)*x99))+(((-1.0)*x83)));
op[46]=0;
op[47]=((((-1.0)*x114))+(((-1.0)*x124))+x79+x97);
op[48]=x139;
op[49]=x103;
op[50]=x129;
op[51]=x104;
op[52]=((((-1.0)*x130))+x54);
op[53]=x116;
op[54]=x105;
op[55]=(x131+(((-1.0)*x51)));
op[56]=x100;
op[57]=(x106+(((-1.0)*x59)));
op[58]=x107;
op[59]=((((-1.0)*x109))+x108);
op[60]=((((-1.0)*x140))+x117);
op[61]=x142;
op[62]=((((-1.0)*x119))+x118);
op[63]=x133;
op[64]=((((-1.0)*x141))+x120);
op[65]=x143;
op[66]=x144;
op[67]=(x134+(((-1.0)*x135)));
op[68]=x136;
op[69]=((((-1.0)*x122))+x121);
op[70]=x145;
op[71]=(x137+(((-1.0)*x138)));
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j0array[16], cj0array[16], sj0array[16], j5array[16], cj5array[16], sj5array[16], j1array[16], cj1array[16], sj1array[16];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ij0 += 3)
{
IkReal htj0 = zeror[ij0+0], htj5 = zeror[ij0+1], htj1 = zeror[ij0+2];
if(isnan(htj0)||isnan(htj5)||isnan(htj1)){
continue;
}
j0array[numsolutions]=((2.0)*(atan(htj0)));
j5array[numsolutions]=((2.0)*(atan(htj5)));
j1array[numsolutions]=((2.0)*(atan(htj1)));
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x146=htj0*htj0;
CheckValue<IkReal> x147=IKPowWithIntegerCheck(((1.0)+x146),-1);
if(!x147.valid){
continue;
}
cj0array[numsolutions]=((x147.value)*(((1.0)+(((-1.0)*x146)))));
CheckValue<IkReal> x148=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x148.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x148.value));
}
if(isinf(htj5)){
cj5array[numsolutions] = IKcos(j5array[numsolutions]);
sj5array[numsolutions] = IKsin(j5array[numsolutions]);
}
else{
IkReal x149=htj5*htj5;
CheckValue<IkReal> x150=IKPowWithIntegerCheck(((1.0)+x149),-1);
if(!x150.valid){
continue;
}
cj5array[numsolutions]=((x150.value)*(((1.0)+(((-1.0)*x149)))));
CheckValue<IkReal> x151=IKPowWithIntegerCheck(((1.0)+(htj5*htj5)),-1);
if(!x151.valid){
continue;
}
sj5array[numsolutions]=((2.0)*htj5*(x151.value));
}
if(isinf(htj1)){
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
}
else{
IkReal x152=htj1*htj1;
CheckValue<IkReal> x153=IKPowWithIntegerCheck(((1.0)+x152),-1);
if(!x153.valid){
continue;
}
cj1array[numsolutions]=((x153.value)*(((1.0)+(((-1.0)*x152)))));
CheckValue<IkReal> x154=IKPowWithIntegerCheck(((1.0)+(htj1*htj1)),-1);
if(!x154.valid){
continue;
}
sj1array[numsolutions]=((2.0)*htj1*(x154.value));
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
if( j5array[numsolutions] > IKPI )
{
    j5array[numsolutions]-=IK2PI;
}
else if( j5array[numsolutions] < -IKPI )
{
    j5array[numsolutions]+=IK2PI;
}
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j0valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj0 = 16;
_nj5 = 1;
_nj1 = 1;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
_ij5[0] = 0; _ij5[1] = -1;
_ij1[0] = 0; _ij1[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( !j0valid[iij0] ) { continue; }
if( IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(cj5array[ij0]-cj5array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij0]-sj5array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(cj1array[ij0]-cj1array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij0]-sj1array[iij0]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j0valid[iij0]=false; _ij0[1] = iij0; _ij5[1] = 0; _ij1[1] = 0;  break; 
}
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

    j5 = j5array[ij0]; cj5 = cj5array[ij0]; sj5 = sj5array[ij0];

    j1 = j1array[ij0]; cj1 = cj1array[ij0]; sj1 = sj1array[ij0];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x155=(r00*sj0*sj5);
IkReal x156=(cj0*cj5*r11);
IkReal x157=(cj0*r10*sj5);
IkReal x158=(cj5*r01*sj0);
if( IKabs(((((526300.0)*x157))+(((526300.0)*x156))+(((100000000.0)*cj0*py))+(((-526300.0)*x155))+(((-526300.0)*x158))+(((-100000000.0)*px*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x155+x158+(((-1.0)*x156))+(((-1.0)*x157)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((526300.0)*x157))+(((526300.0)*x156))+(((100000000.0)*cj0*py))+(((-526300.0)*x155))+(((-526300.0)*x158))+(((-100000000.0)*px*sj0))))+IKsqr((x155+x158+(((-1.0)*x156))+(((-1.0)*x157))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((((526300.0)*x157))+(((526300.0)*x156))+(((100000000.0)*cj0*py))+(((-526300.0)*x155))+(((-526300.0)*x158))+(((-100000000.0)*px*sj0))), (x155+x158+(((-1.0)*x156))+(((-1.0)*x157))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x159=IKcos(j3);
IkReal x160=((1.0)*cj0);
evalcond[0]=((((-0.005263)*x159))+(((-1.0e-8)*(IKsin(j3))))+(((-1.0)*px*sj0))+((cj0*py)));
evalcond[1]=(((r00*sj0*sj5))+((cj5*r01*sj0))+(((-1.0)*x159))+(((-1.0)*cj5*r11*x160))+(((-1.0)*r10*sj5*x160)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[2];
j2eval[0]=sj3;
j2eval[1]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x161=cj3*cj3;
IkReal x162=(cj3*sj3);
j2eval[0]=((-526300.0)+(((526300.0)*x161))+x162);
j2eval[1]=IKsign(((-0.005263)+(((0.005263)*x161))+(((1.0e-8)*x162))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
IkReal x163=cj5*cj5;
IkReal x164=cj0*cj0;
IkReal x165=r01*r01;
IkReal x166=r00*r00;
IkReal x167=r11*r11;
IkReal x168=r02*r02;
IkReal x169=(cj0*sj3);
IkReal x170=(cj5*sj5);
IkReal x171=((2.0)*r11);
IkReal x172=(r00*sj0);
IkReal x173=(r02*sj0);
IkReal x174=((1.0)*x163);
IkReal x175=(cj0*r01*sj0);
IkReal x176=((2.0)*r00*r01);
IkReal x177=((2.0)*cj0*r10*sj0);
IkReal x178=(x164*x167);
IkReal x179=(x164*x165);
IkReal x180=((((-1.0)*x174*x179))+(((-1.0)*x164*x174*(r10*r10)))+(((-1.0)*x164*x170*x176))+(((2.0)*cj0*r12*x173))+(((-1.0)*x178))+x179+((x163*x164*x166))+(((-1.0)*x165))+(((-1.0)*x168))+((x164*x168))+(((-2.0)*r10*x170*x175))+(((-1.0)*x164*(r12*r12)))+((x171*x175))+(((2.0)*cj0*r10*x163*x172))+(((-1.0)*x163*x171*x175))+((x170*x176))+((r10*x164*x170*x171))+((x163*x178))+((x163*x165))+(((-1.0)*cj0*x170*x171*x172))+(((-1.0)*x166*x174)));
j4eval[0]=x180;
j4eval[1]=IKsign(x180);
j4eval[2]=((IKabs(((((-1.0)*r12*x169))+((sj3*x173)))))+(IKabs(((((-1.0)*r11*sj5*x169))+(((-1.0)*cj5*sj3*x172))+((r01*sj0*sj3*sj5))+((cj5*r10*x169))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x181=((1.07497984412792e-7)*pz);
IkReal x182=((3.27868852459016)*cj1);
IkReal x183=(cj0*px);
IkReal x184=(py*sj0);
IkReal x185=((1.07497984412792e-7)*cj1);
IkReal x186=((3.27868852459016)*sj1);
IkReal x187=((1.07497984412792e-7)*sj1);
if( IKabs(((3.76242945444773e-8)+((pz*x186))+((x184*x187))+(((-1.0)*cj1*x181))+((x183*x187))+((x182*x183))+((x182*x184)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.14754098360656)+((pz*x182))+((sj1*x181))+((x184*x185))+(((-1.0)*x184*x186))+(((-1.0)*x183*x186))+((x183*x185)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.76242945444773e-8)+((pz*x186))+((x184*x187))+(((-1.0)*cj1*x181))+((x183*x187))+((x182*x183))+((x182*x184))))+IKsqr(((-1.14754098360656)+((pz*x182))+((sj1*x181))+((x184*x185))+(((-1.0)*x184*x186))+(((-1.0)*x183*x186))+((x183*x185))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((3.76242945444773e-8)+((pz*x186))+((x184*x187))+(((-1.0)*cj1*x181))+((x183*x187))+((x182*x183))+((x182*x184))), ((-1.14754098360656)+((pz*x182))+((sj1*x181))+((x184*x185))+(((-1.0)*x184*x186))+(((-1.0)*x183*x186))+((x183*x185))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
IkReal x188=IKcos(j2);
IkReal x189=IKsin(j2);
IkReal x190=((0.305)*cj1);
IkReal x191=((0.305)*sj1);
IkReal x192=((1.0e-8)*x189);
IkReal x193=((1.0e-8)*x188);
evalcond[0]=(((sj1*x193))+((x188*x190))+((x189*x191))+(((-1.0)*pz))+(((-1.0)*cj1*x192))+(((0.35)*cj1)));
evalcond[1]=((((-1.0)*x188*x191))+((sj1*x192))+((x189*x190))+(((-0.35)*sj1))+((cj1*x193))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[2];
sj3=0;
cj3=1.0;
j3=0;
IkReal x194=cj5*cj5;
IkReal x195=r21*r21;
IkReal x196=((r22*r22)+(((-1.0)*x194*x195))+((x194*(r20*r20)))+x195+(((-2.0)*cj5*r20*r21*sj5)));
j4eval[0]=x196;
j4eval[1]=IKsign(x196);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj3=0;
cj3=1.0;
j3=0;
IkReal x197=(((cj0*cj5*r01))+((cj5*r11*sj0))+((cj0*r00*sj5))+((r10*sj0*sj5)));
j4eval[0]=x197;
j4eval[1]=IKsign(x197);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj3=0;
cj3=1.0;
j3=0;
IkReal x198=cj5*cj5;
IkReal x199=(r00*sj0);
IkReal x200=((1.0)*sj0);
IkReal x201=(r01*r21);
IkReal x202=(cj0*r10);
IkReal x203=(cj0*r11*r21);
IkReal x204=(cj5*r21*sj5);
IkReal x205=((1.0)*x198);
IkReal x206=(cj5*r20*sj5);
IkReal x207=(((sj0*x198*x201))+(((-1.0)*x200*x201))+(((-1.0)*r02*r22*x200))+(((-1.0)*x203*x205))+((r20*x198*x202))+x203+((r01*sj0*x206))+(((-1.0)*cj0*r11*x206))+(((-1.0)*x202*x204))+((cj0*r12*r22))+(((-1.0)*r20*x199*x205))+((x199*x204)));
j4eval[0]=x207;
j4eval[1]=IKsign(x207);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x208=cj5*cj5;
IkReal x209=(sj1*sj2);
IkReal x210=(r01*sj0);
IkReal x211=(cj0*r10);
IkReal x212=((1.0)*sj5);
IkReal x213=(cj5*r21);
IkReal x214=(cj1*cj2);
IkReal x215=(cj0*r11);
IkReal x216=(cj5*r20);
IkReal x217=(cj0*r12);
IkReal x218=(r20*x208);
IkReal x219=((1.0)*r02*sj0);
IkReal x220=(r21*x208);
IkReal x221=((1.0)*r00*sj0);
CheckValue<IkReal> x222=IKPowWithIntegerCheck(IKsign((((x210*x220))+((r21*x215))+(((-1.0)*x212*x215*x216))+(((-1.0)*x215*x220))+((sj5*x210*x216))+(((-1.0)*r22*x219))+((x211*x218))+((r00*sj0*sj5*x213))+(((-1.0)*x218*x221))+((r22*x217))+(((-1.0)*x211*x212*x213))+(((-1.0)*r21*x210)))),-1);
if(!x222.valid){
continue;
}
CheckValue<IkReal> x223 = IKatan2WithCheck(IkReal(((((-1.0)*x212*x214*x215))+(((-1.0)*x209*x212*x215))+((sj5*x210*x214))+((sj5*x209*x210))+(((-1.0)*cj5*x209*x221))+(((-1.0)*cj5*x214*x221))+((cj5*x211*x214))+((cj5*x209*x211)))),IkReal((((x214*x217))+((x209*x217))+(((-1.0)*x214*x219))+(((-1.0)*x209*x219)))),IKFAST_ATAN2_MAGTHRESH);
if(!x223.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x222.value)))+(x223.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x224=IKsin(j4);
IkReal x225=IKcos(j4);
IkReal x226=(cj2*sj1);
IkReal x227=(r12*sj0);
IkReal x228=(r01*sj5);
IkReal x229=(sj1*sj2);
IkReal x230=((1.0)*cj1);
IkReal x231=(r02*sj0);
IkReal x232=(cj5*r10);
IkReal x233=(r11*sj5);
IkReal x234=(r21*sj5);
IkReal x235=(r00*sj0);
IkReal x236=(sj2*x230);
IkReal x237=((1.0)*x224);
IkReal x238=(cj0*x225);
IkReal x239=(cj5*x224);
IkReal x240=(cj0*x224);
IkReal x241=((1.0)*x225);
IkReal x242=(cj5*x225);
evalcond[0]=(((r20*x239))+(((-1.0)*x234*x237))+(((-1.0)*cj2*x230))+((r22*x225))+(((-1.0)*x229)));
evalcond[1]=((((-1.0)*r22*x237))+(((-1.0)*x234*x241))+(((-1.0)*x236))+x226+((r20*x242)));
evalcond[2]=(((x233*x240))+(((-1.0)*sj0*x228*x237))+((x235*x239))+((x225*x231))+(((-1.0)*r12*x238))+(((-1.0)*cj0*x232*x237)));
evalcond[3]=((((-1.0)*sj0*x228*x241))+(((-1.0)*x232*x238))+((x233*x238))+((r12*x240))+(((-1.0)*x231*x237))+((x235*x242)));
evalcond[4]=(((r02*x238))+((x225*x227))+((cj0*r00*x239))+(((-1.0)*sj0*x233*x237))+(((-1.0)*cj0*x228*x237))+(((-1.0)*x236))+x226+((sj0*x224*x232)));
evalcond[5]=((((-1.0)*cj0*r02*x237))+((cj5*r00*x238))+(((-1.0)*x227*x237))+(((-1.0)*sj0*x233*x241))+x229+(((-1.0)*x228*x238))+((cj1*cj2))+((sj0*x225*x232)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x243=(cj1*cj2);
IkReal x244=(cj5*sj0);
IkReal x245=(sj1*sj2);
IkReal x246=(cj0*r12);
IkReal x247=(cj0*cj5);
IkReal x248=((1.0)*r10);
IkReal x249=(sj0*sj5);
IkReal x250=((1.0)*r01);
IkReal x251=(cj0*r11*sj5);
IkReal x252=((1.0)*r02*sj0);
CheckValue<IkReal> x253 = IKatan2WithCheck(IkReal(((((-1.0)*x245*x252))+((x245*x246))+((x243*x246))+(((-1.0)*x243*x252)))),IkReal((((x245*x251))+(((-1.0)*x243*x249*x250))+(((-1.0)*x243*x247*x248))+((r00*x243*x244))+(((-1.0)*x245*x249*x250))+((x243*x251))+(((-1.0)*x245*x247*x248))+((r00*x244*x245)))),IKFAST_ATAN2_MAGTHRESH);
if(!x253.valid){
continue;
}
CheckValue<IkReal> x254=IKPowWithIntegerCheck(IKsign((((cj0*r00*sj5))+((r01*x247))+((r11*x244))+((r10*x249)))),-1);
if(!x254.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x253.value)+(((1.5707963267949)*(x254.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x255=IKsin(j4);
IkReal x256=IKcos(j4);
IkReal x257=(cj2*sj1);
IkReal x258=(r12*sj0);
IkReal x259=(r01*sj5);
IkReal x260=(sj1*sj2);
IkReal x261=((1.0)*cj1);
IkReal x262=(r02*sj0);
IkReal x263=(cj5*r10);
IkReal x264=(r11*sj5);
IkReal x265=(r21*sj5);
IkReal x266=(r00*sj0);
IkReal x267=(sj2*x261);
IkReal x268=((1.0)*x255);
IkReal x269=(cj0*x256);
IkReal x270=(cj5*x255);
IkReal x271=(cj0*x255);
IkReal x272=((1.0)*x256);
IkReal x273=(cj5*x256);
evalcond[0]=((((-1.0)*x260))+(((-1.0)*cj2*x261))+(((-1.0)*x265*x268))+((r22*x256))+((r20*x270)));
evalcond[1]=(x257+(((-1.0)*x265*x272))+(((-1.0)*r22*x268))+(((-1.0)*x267))+((r20*x273)));
evalcond[2]=((((-1.0)*sj0*x259*x268))+((x266*x270))+(((-1.0)*r12*x269))+((x264*x271))+((x256*x262))+(((-1.0)*cj0*x263*x268)));
evalcond[3]=((((-1.0)*x262*x268))+((x266*x273))+(((-1.0)*sj0*x259*x272))+((x264*x269))+((r12*x271))+(((-1.0)*x263*x269)));
evalcond[4]=((((-1.0)*cj0*x259*x268))+((r02*x269))+((cj0*r00*x270))+((x256*x258))+x257+((sj0*x255*x263))+(((-1.0)*sj0*x264*x268))+(((-1.0)*x267)));
evalcond[5]=((((-1.0)*x258*x268))+((sj0*x256*x263))+((cj5*r00*x269))+(((-1.0)*x259*x269))+x260+(((-1.0)*cj0*r02*x268))+((cj1*cj2))+(((-1.0)*sj0*x264*x272)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x274=cj5*cj5;
IkReal x275=r21*r21;
IkReal x276=(cj5*r20);
IkReal x277=((1.0)*sj1);
IkReal x278=(cj1*sj2);
IkReal x279=(r21*sj5);
IkReal x280=(cj1*cj2);
IkReal x281=(r22*sj1);
CheckValue<IkReal> x282=IKPowWithIntegerCheck(IKsign((((x274*(r20*r20)))+(r22*r22)+(((-1.0)*x274*x275))+(((-2.0)*x276*x279))+x275)),-1);
if(!x282.valid){
continue;
}
CheckValue<IkReal> x283 = IKatan2WithCheck(IkReal((((cj2*x281))+(((-1.0)*x279*x280))+(((-1.0)*sj2*x277*x279))+((sj1*sj2*x276))+(((-1.0)*r22*x278))+((x276*x280)))),IkReal((((cj2*sj1*x279))+((sj2*x281))+((r22*x280))+((x276*x278))+(((-1.0)*x278*x279))+(((-1.0)*cj2*x276*x277)))),IKFAST_ATAN2_MAGTHRESH);
if(!x283.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x282.value)))+(x283.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x284=IKsin(j4);
IkReal x285=IKcos(j4);
IkReal x286=(cj2*sj1);
IkReal x287=(r12*sj0);
IkReal x288=(r01*sj5);
IkReal x289=(sj1*sj2);
IkReal x290=((1.0)*cj1);
IkReal x291=(r02*sj0);
IkReal x292=(cj5*r10);
IkReal x293=(r11*sj5);
IkReal x294=(r21*sj5);
IkReal x295=(r00*sj0);
IkReal x296=(sj2*x290);
IkReal x297=((1.0)*x284);
IkReal x298=(cj0*x285);
IkReal x299=(cj5*x284);
IkReal x300=(cj0*x284);
IkReal x301=((1.0)*x285);
IkReal x302=(cj5*x285);
evalcond[0]=(((r22*x285))+((r20*x299))+(((-1.0)*x289))+(((-1.0)*cj2*x290))+(((-1.0)*x294*x297)));
evalcond[1]=((((-1.0)*x294*x301))+(((-1.0)*x296))+x286+((r20*x302))+(((-1.0)*r22*x297)));
evalcond[2]=((((-1.0)*sj0*x288*x297))+((x293*x300))+((x285*x291))+(((-1.0)*cj0*x292*x297))+((x295*x299))+(((-1.0)*r12*x298)));
evalcond[3]=((((-1.0)*x291*x297))+(((-1.0)*sj0*x288*x301))+((x295*x302))+(((-1.0)*x292*x298))+((x293*x298))+((r12*x300)));
evalcond[4]=(((x285*x287))+(((-1.0)*x296))+x286+((sj0*x284*x292))+(((-1.0)*sj0*x293*x297))+((r02*x298))+(((-1.0)*cj0*x288*x297))+((cj0*r00*x299)));
evalcond[5]=((((-1.0)*x288*x298))+x289+(((-1.0)*sj0*x293*x301))+(((-1.0)*x287*x297))+((sj0*x285*x292))+((cj1*cj2))+(((-1.0)*cj0*r02*x297))+((cj5*r00*x298)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x303=((1.07497984412792e-7)*pz);
IkReal x304=((3.27868852459016)*cj1);
IkReal x305=(cj0*px);
IkReal x306=(py*sj0);
IkReal x307=((1.07497984412792e-7)*cj1);
IkReal x308=((3.27868852459016)*sj1);
IkReal x309=((1.07497984412792e-7)*sj1);
if( IKabs(((-3.76242945444773e-8)+((cj1*x303))+(((-1.0)*x306*x309))+(((-1.0)*x305*x309))+((x304*x306))+((x304*x305))+((pz*x308)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.14754098360656)+(((-1.0)*sj1*x303))+(((-1.0)*x306*x307))+(((-1.0)*x306*x308))+(((-1.0)*x305*x307))+(((-1.0)*x305*x308))+((pz*x304)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.76242945444773e-8)+((cj1*x303))+(((-1.0)*x306*x309))+(((-1.0)*x305*x309))+((x304*x306))+((x304*x305))+((pz*x308))))+IKsqr(((-1.14754098360656)+(((-1.0)*sj1*x303))+(((-1.0)*x306*x307))+(((-1.0)*x306*x308))+(((-1.0)*x305*x307))+(((-1.0)*x305*x308))+((pz*x304))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((-3.76242945444773e-8)+((cj1*x303))+(((-1.0)*x306*x309))+(((-1.0)*x305*x309))+((x304*x306))+((x304*x305))+((pz*x308))), ((-1.14754098360656)+(((-1.0)*sj1*x303))+(((-1.0)*x306*x307))+(((-1.0)*x306*x308))+(((-1.0)*x305*x307))+(((-1.0)*x305*x308))+((pz*x304))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[2];
IkReal x310=IKsin(j2);
IkReal x311=IKcos(j2);
IkReal x312=((0.305)*cj1);
IkReal x313=((0.305)*sj1);
IkReal x314=((1.0e-8)*x310);
IkReal x315=((1.0e-8)*x311);
evalcond[0]=(((x310*x313))+(((-1.0)*sj1*x315))+((cj1*x314))+(((-1.0)*pz))+((x311*x312))+(((0.35)*cj1)));
evalcond[1]=(((x310*x312))+(((-1.0)*sj1*x314))+(((-0.35)*sj1))+(((-1.0)*cj1*x315))+(((-1.0)*py*sj0))+(((-1.0)*x311*x313))+(((-1.0)*cj0*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[2];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x316=cj5*cj5;
IkReal x317=r21*r21;
IkReal x318=((r22*r22)+((x316*(r20*r20)))+(((-1.0)*x316*x317))+x317+(((-2.0)*cj5*r20*r21*sj5)));
j4eval[0]=x318;
j4eval[1]=IKsign(x318);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x319=(((cj0*cj5*r01))+((cj5*r11*sj0))+((cj0*r00*sj5))+((r10*sj0*sj5)));
j4eval[0]=x319;
j4eval[1]=IKsign(x319);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
sj3=0;
cj3=-1.0;
j3=3.14159265358979;
IkReal x320=cj5*cj5;
IkReal x321=(r00*sj0);
IkReal x322=((1.0)*sj0);
IkReal x323=(r01*r21);
IkReal x324=(cj0*r10);
IkReal x325=(cj0*r11*r21);
IkReal x326=(cj5*r21*sj5);
IkReal x327=((1.0)*x320);
IkReal x328=(cj5*r20*sj5);
IkReal x329=(((r20*x320*x324))+(((-1.0)*r20*x321*x327))+(((-1.0)*x325*x327))+((sj0*x320*x323))+(((-1.0)*r02*r22*x322))+((r01*sj0*x328))+(((-1.0)*x322*x323))+(((-1.0)*x324*x326))+x325+(((-1.0)*cj0*r11*x328))+((cj0*r12*r22))+((x321*x326)));
j4eval[0]=x329;
j4eval[1]=IKsign(x329);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x330=cj5*cj5;
IkReal x331=(sj1*sj2);
IkReal x332=(r01*sj0);
IkReal x333=(cj0*r10);
IkReal x334=((1.0)*sj5);
IkReal x335=(cj5*r21);
IkReal x336=(cj1*cj2);
IkReal x337=(cj0*r11);
IkReal x338=(cj5*r20);
IkReal x339=(cj0*r12);
IkReal x340=(r20*x330);
IkReal x341=((1.0)*r02*sj0);
IkReal x342=(r21*x330);
IkReal x343=((1.0)*r00*sj0);
CheckValue<IkReal> x344=IKPowWithIntegerCheck(IKsign((((r22*x339))+(((-1.0)*r22*x341))+((r00*sj0*sj5*x335))+(((-1.0)*x334*x337*x338))+((r21*x337))+((sj5*x332*x338))+(((-1.0)*r21*x332))+((x333*x340))+((x332*x342))+(((-1.0)*x337*x342))+(((-1.0)*x340*x343))+(((-1.0)*x333*x334*x335)))),-1);
if(!x344.valid){
continue;
}
CheckValue<IkReal> x345 = IKatan2WithCheck(IkReal((((cj5*x333*x336))+(((-1.0)*x334*x336*x337))+((sj5*x331*x332))+(((-1.0)*cj5*x331*x343))+((sj5*x332*x336))+(((-1.0)*cj5*x336*x343))+((cj5*x331*x333))+(((-1.0)*x331*x334*x337)))),IkReal((((x336*x339))+(((-1.0)*x336*x341))+((x331*x339))+(((-1.0)*x331*x341)))),IKFAST_ATAN2_MAGTHRESH);
if(!x345.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x344.value)))+(x345.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x346=IKsin(j4);
IkReal x347=IKcos(j4);
IkReal x348=(r12*sj0);
IkReal x349=(r01*sj5);
IkReal x350=(cj5*r00);
IkReal x351=(cj5*r20);
IkReal x352=((1.0)*cj1);
IkReal x353=((1.0)*sj1);
IkReal x354=((1.0)*sj5);
IkReal x355=(cj5*r10);
IkReal x356=(r11*sj5);
IkReal x357=(cj2*x352);
IkReal x358=(sj2*x353);
IkReal x359=((1.0)*x346);
IkReal x360=(cj0*x347);
IkReal x361=(sj0*x347);
IkReal x362=(cj0*x346);
IkReal x363=(sj0*x346);
IkReal x364=(x357+x358);
evalcond[0]=((((-1.0)*x364))+(((-1.0)*r21*x346*x354))+((x346*x351))+((r22*x347)));
evalcond[1]=((((-1.0)*r22*x359))+(((-1.0)*cj2*x353))+((cj1*sj2))+(((-1.0)*r21*x347*x354))+((x347*x351)));
evalcond[2]=(((x350*x363))+(((-1.0)*cj0*x355*x359))+(((-1.0)*sj0*x349*x359))+((x356*x362))+(((-1.0)*r12*x360))+((r02*x361)));
evalcond[3]=(((x350*x361))+((x356*x360))+((r12*x362))+(((-1.0)*x349*x361))+(((-1.0)*x355*x360))+(((-1.0)*r02*sj0*x359)));
evalcond[4]=((((-1.0)*sj2*x352))+((cj2*sj1))+(((-1.0)*r11*x354*x363))+((x350*x362))+((x355*x363))+(((-1.0)*cj0*x349*x359))+((x347*x348))+((r02*x360)));
evalcond[5]=((((-1.0)*cj0*r02*x359))+(((-1.0)*r11*x354*x361))+((x350*x360))+(((-1.0)*x348*x359))+(((-1.0)*x364))+((x355*x361))+(((-1.0)*x349*x360)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x365=(cj1*cj2);
IkReal x366=(cj5*sj0);
IkReal x367=(sj1*sj2);
IkReal x368=(cj0*r12);
IkReal x369=(cj0*cj5);
IkReal x370=((1.0)*r10);
IkReal x371=(sj0*sj5);
IkReal x372=((1.0)*r01);
IkReal x373=(cj0*r11*sj5);
IkReal x374=((1.0)*r02*sj0);
CheckValue<IkReal> x375 = IKatan2WithCheck(IkReal((((x365*x368))+(((-1.0)*x367*x374))+((x367*x368))+(((-1.0)*x365*x374)))),IkReal((((x367*x373))+(((-1.0)*x365*x371*x372))+(((-1.0)*x367*x371*x372))+((x365*x373))+(((-1.0)*x367*x369*x370))+((r00*x365*x366))+((r00*x366*x367))+(((-1.0)*x365*x369*x370)))),IKFAST_ATAN2_MAGTHRESH);
if(!x375.valid){
continue;
}
CheckValue<IkReal> x376=IKPowWithIntegerCheck(IKsign((((r01*x369))+((cj0*r00*sj5))+((r11*x366))+((r10*x371)))),-1);
if(!x376.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x375.value)+(((1.5707963267949)*(x376.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x377=IKsin(j4);
IkReal x378=IKcos(j4);
IkReal x379=(r12*sj0);
IkReal x380=(r01*sj5);
IkReal x381=(cj5*r00);
IkReal x382=(cj5*r20);
IkReal x383=((1.0)*cj1);
IkReal x384=((1.0)*sj1);
IkReal x385=((1.0)*sj5);
IkReal x386=(cj5*r10);
IkReal x387=(r11*sj5);
IkReal x388=(cj2*x383);
IkReal x389=(sj2*x384);
IkReal x390=((1.0)*x377);
IkReal x391=(cj0*x378);
IkReal x392=(sj0*x378);
IkReal x393=(cj0*x377);
IkReal x394=(sj0*x377);
IkReal x395=(x388+x389);
evalcond[0]=(((x377*x382))+(((-1.0)*x395))+(((-1.0)*r21*x377*x385))+((r22*x378)));
evalcond[1]=(((x378*x382))+(((-1.0)*cj2*x384))+((cj1*sj2))+(((-1.0)*r21*x378*x385))+(((-1.0)*r22*x390)));
evalcond[2]=((((-1.0)*cj0*x386*x390))+(((-1.0)*r12*x391))+(((-1.0)*sj0*x380*x390))+((x381*x394))+((x387*x393))+((r02*x392)));
evalcond[3]=((((-1.0)*x380*x392))+((x381*x392))+(((-1.0)*r02*sj0*x390))+((x387*x391))+((r12*x393))+(((-1.0)*x386*x391)));
evalcond[4]=(((cj2*sj1))+((x381*x393))+(((-1.0)*cj0*x380*x390))+(((-1.0)*r11*x385*x394))+((x378*x379))+(((-1.0)*sj2*x383))+((x386*x394))+((r02*x391)));
evalcond[5]=((((-1.0)*x395))+(((-1.0)*x380*x391))+((x381*x391))+(((-1.0)*r11*x385*x392))+(((-1.0)*cj0*r02*x390))+(((-1.0)*x379*x390))+((x386*x392)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x396=cj5*cj5;
IkReal x397=r21*r21;
IkReal x398=(cj1*cj2);
IkReal x399=(sj1*sj2);
IkReal x400=(cj5*r20);
IkReal x401=(cj2*sj1);
IkReal x402=(r21*sj5);
IkReal x403=(cj1*sj2);
IkReal x404=((1.0)*x402);
CheckValue<IkReal> x405=IKPowWithIntegerCheck(IKsign(((((-2.0)*x400*x402))+(r22*r22)+((x396*(r20*r20)))+x397+(((-1.0)*x396*x397)))),-1);
if(!x405.valid){
continue;
}
CheckValue<IkReal> x406 = IKatan2WithCheck(IkReal((((r22*x403))+(((-1.0)*x398*x404))+(((-1.0)*x399*x404))+((x399*x400))+(((-1.0)*r22*x401))+((x398*x400)))),IkReal(((((-1.0)*x401*x404))+((r22*x399))+((r22*x398))+((x400*x401))+((x402*x403))+(((-1.0)*x400*x403)))),IKFAST_ATAN2_MAGTHRESH);
if(!x406.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x405.value)))+(x406.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x407=IKsin(j4);
IkReal x408=IKcos(j4);
IkReal x409=(r12*sj0);
IkReal x410=(r01*sj5);
IkReal x411=(cj5*r00);
IkReal x412=(cj5*r20);
IkReal x413=((1.0)*cj1);
IkReal x414=((1.0)*sj1);
IkReal x415=((1.0)*sj5);
IkReal x416=(cj5*r10);
IkReal x417=(r11*sj5);
IkReal x418=(cj2*x413);
IkReal x419=(sj2*x414);
IkReal x420=((1.0)*x407);
IkReal x421=(cj0*x408);
IkReal x422=(sj0*x408);
IkReal x423=(cj0*x407);
IkReal x424=(sj0*x407);
IkReal x425=(x418+x419);
evalcond[0]=(((x407*x412))+((r22*x408))+(((-1.0)*x425))+(((-1.0)*r21*x407*x415)));
evalcond[1]=((((-1.0)*r21*x408*x415))+(((-1.0)*cj2*x414))+((cj1*sj2))+((x408*x412))+(((-1.0)*r22*x420)));
evalcond[2]=((((-1.0)*r12*x421))+(((-1.0)*cj0*x416*x420))+((x411*x424))+((r02*x422))+(((-1.0)*sj0*x410*x420))+((x417*x423)));
evalcond[3]=((((-1.0)*r02*sj0*x420))+(((-1.0)*x416*x421))+((x411*x422))+(((-1.0)*x410*x422))+((r12*x423))+((x417*x421)));
evalcond[4]=(((cj2*sj1))+(((-1.0)*cj0*x410*x420))+((x411*x423))+((r02*x421))+((x408*x409))+((x416*x424))+(((-1.0)*r11*x415*x424))+(((-1.0)*sj2*x413)));
evalcond[5]=((((-1.0)*x425))+(((-1.0)*cj0*r02*x420))+((x411*x421))+(((-1.0)*x410*x421))+((x416*x422))+(((-1.0)*x409*x420))+(((-1.0)*r11*x415*x422)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x426=cj5*cj5;
IkReal x427=cj0*cj0;
IkReal x428=r01*r01;
IkReal x429=r00*r00;
IkReal x430=r11*r11;
IkReal x431=r02*r02;
IkReal x432=(cj0*sj3);
IkReal x433=(cj5*sj5);
IkReal x434=((2.0)*r11);
IkReal x435=(r00*sj0);
IkReal x436=(r02*sj0);
IkReal x437=((1.0)*x426);
IkReal x438=(cj0*r01*sj0);
IkReal x439=((2.0)*r00*r01);
IkReal x440=((2.0)*cj0*r10*sj0);
IkReal x441=(x427*x430);
IkReal x442=(x427*x428);
CheckValue<IkReal> x443=IKPowWithIntegerCheck(IKsign((((x426*x428))+(((-1.0)*x428))+(((-1.0)*x437*x442))+(((-1.0)*x431))+(((-1.0)*x426*x434*x438))+((x434*x438))+(((-1.0)*x427*(r12*r12)))+((x426*x441))+(((-1.0)*x441))+(((-1.0)*x427*x437*(r10*r10)))+(((-1.0)*x429*x437))+(((2.0)*cj0*r12*x436))+(((-2.0)*r10*x433*x438))+(((2.0)*cj0*r10*x426*x435))+x442+((r10*x427*x433*x434))+((x433*x439))+(((-1.0)*x427*x433*x439))+((x426*x427*x429))+(((-1.0)*cj0*x433*x434*x435))+((x427*x431)))),-1);
if(!x443.valid){
continue;
}
CheckValue<IkReal> x444 = IKatan2WithCheck(IkReal(((((-1.0)*r12*x432))+((sj3*x436)))),IkReal((((cj5*r10*x432))+(((-1.0)*cj5*sj3*x435))+(((-1.0)*r11*sj5*x432))+((r01*sj0*sj3*sj5)))),IKFAST_ATAN2_MAGTHRESH);
if(!x444.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x443.value)))+(x444.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x445=IKsin(j4);
IkReal x446=IKcos(j4);
IkReal x447=(cj5*r10);
IkReal x448=(r11*sj5);
IkReal x449=(cj5*r00);
IkReal x450=(cj0*x445);
IkReal x451=(sj0*x445);
IkReal x452=(sj0*x446);
IkReal x453=((1.0)*r01*sj5);
IkReal x454=((1.0)*cj0*x446);
evalcond[0]=((((-1.0)*x447*x450))+(((-1.0)*r12*x454))+((x449*x451))+((r02*x452))+((x448*x450))+(((-1.0)*x451*x453)));
evalcond[1]=((((-1.0)*sj3))+((cj0*x446*x448))+(((-1.0)*r02*x451))+(((-1.0)*x447*x454))+((x449*x452))+(((-1.0)*x452*x453))+((r12*x450)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j2eval[3];
IkReal x455=(sj3*sj4);
IkReal x456=(r20*sj5);
IkReal x457=(cj5*r20);
IkReal x458=(r21*sj1);
IkReal x459=((1.0)*cj1*r21);
IkReal x460=(cj4*r22*sj3);
j2eval[0]=sj3;
j2eval[1]=((IKabs(((((-1.0)*sj5*x455*x458))+((sj1*x455*x457))+(((-1.0)*cj1*x456))+(((-1.0)*cj5*x459))+((sj1*x460)))))+(IKabs((((cj5*x458))+(((-1.0)*sj5*x455*x459))+((cj1*x460))+((sj1*x456))+((cj1*x455*x457))))));
j2eval[2]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=sj3;
j2eval[1]=IKsign(sj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=cj3;
j2eval[1]=IKsign(cj3);
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x461=(sj4*sj5);
IkReal x462=(cj1*r20);
IkReal x463=(cj5*sj4);
IkReal x464=(cj4*r22);
IkReal x465=(r20*sj1);
IkReal x466=(r21*sj1);
IkReal x467=((1.0)*cj1*r21);
if( IKabs(((((-1.0)*x461*x466))+(((-1.0)*sj5*x462))+((x463*x465))+(((-1.0)*cj5*x467))+((sj1*x464)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj5*x466))+((cj1*x464))+(((-1.0)*x461*x467))+((sj5*x465))+((x462*x463)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x461*x466))+(((-1.0)*sj5*x462))+((x463*x465))+(((-1.0)*cj5*x467))+((sj1*x464))))+IKsqr((((cj5*x466))+((cj1*x464))+(((-1.0)*x461*x467))+((sj5*x465))+((x462*x463))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((((-1.0)*x461*x466))+(((-1.0)*sj5*x462))+((x463*x465))+(((-1.0)*cj5*x467))+((sj1*x464))), (((cj5*x466))+((cj1*x464))+(((-1.0)*x461*x467))+((sj5*x465))+((x462*x463))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x468=IKsin(j2);
IkReal x469=IKcos(j2);
IkReal x470=(sj0*sj5);
IkReal x471=((1.0)*cj0);
IkReal x472=((1.0)*sj4);
IkReal x473=(cj0*cj5);
IkReal x474=(cj5*sj0);
IkReal x475=(cj1*x468);
IkReal x476=((1.0)*x469);
IkReal x477=(sj1*x468);
IkReal x478=((0.305)*x469);
IkReal x479=(sj1*x469);
IkReal x480=((1.0)*x477);
IkReal x481=(cj1*x476);
IkReal x482=(x481+x480);
evalcond[0]=(((cj5*r21))+(((-1.0)*sj1*x476))+x475+((r20*sj5)));
evalcond[1]=(((cj4*r22))+(((-1.0)*x482))+((cj5*r20*sj4))+(((-1.0)*r21*sj5*x472)));
evalcond[2]=(((r10*x470))+(((-1.0)*x482))+((r11*x474))+((cj0*r00*sj5))+((r01*x473)));
evalcond[3]=((((-0.005263)*x479))+(((0.305)*x477))+((cj1*x478))+(((-1.0)*pz))+(((0.005263)*x475))+(((0.35)*cj1)));
evalcond[4]=((((-0.005263)*x477))+(((0.305)*x475))+(((-1.0)*sj1*x478))+(((-0.35)*sj1))+(((-0.005263)*cj1*x469))+(((-1.0)*px*x471))+(((-1.0)*py*sj0)));
evalcond[5]=((((-1.0)*r11*x470*x472))+((r10*sj4*x474))+(((-1.0)*r01*sj4*sj5*x471))+((r00*sj4*x473))+((cj0*cj4*r02))+(((-1.0)*x475))+x479+((cj4*r12*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x483=(cj1*sj4);
IkReal x484=((1.0)*r21);
IkReal x485=(cj5*r20);
IkReal x486=(sj1*sj5);
IkReal x487=(cj4*r22);
if( IKabs((((cj1*r20*sj5))+((cj1*cj5*r21))+((sj1*x487))+((sj1*sj4*x485))+(((-1.0)*sj4*x484*x486)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj5*x483*x484))+(((-1.0)*r20*x486))+(((-1.0)*cj5*sj1*x484))+((x483*x485))+((cj1*x487)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r20*sj5))+((cj1*cj5*r21))+((sj1*x487))+((sj1*sj4*x485))+(((-1.0)*sj4*x484*x486))))+IKsqr(((((-1.0)*sj5*x483*x484))+(((-1.0)*r20*x486))+(((-1.0)*cj5*sj1*x484))+((x483*x485))+((cj1*x487))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj1*r20*sj5))+((cj1*cj5*r21))+((sj1*x487))+((sj1*sj4*x485))+(((-1.0)*sj4*x484*x486))), ((((-1.0)*sj5*x483*x484))+(((-1.0)*r20*x486))+(((-1.0)*cj5*sj1*x484))+((x483*x485))+((cj1*x487))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x488=IKsin(j2);
IkReal x489=IKcos(j2);
IkReal x490=(sj0*sj5);
IkReal x491=((1.0)*cj0);
IkReal x492=((1.0)*sj4);
IkReal x493=(cj0*cj5);
IkReal x494=(cj5*sj0);
IkReal x495=(sj1*x489);
IkReal x496=(cj1*x489);
IkReal x497=(cj1*x488);
IkReal x498=(sj1*x488);
IkReal x499=((1.0)*x497);
evalcond[0]=(((cj5*r21))+(((-1.0)*x499))+x495+((r20*sj5)));
evalcond[1]=(((cj4*r22))+((cj5*r20*sj4))+(((-1.0)*x496))+(((-1.0)*x498))+(((-1.0)*r21*sj5*x492)));
evalcond[2]=(((r11*x494))+x498+x496+((r10*x490))+((cj0*r00*sj5))+((r01*x493)));
evalcond[3]=((((0.005263)*x495))+(((-1.0)*pz))+(((-0.005263)*x497))+(((0.305)*x498))+(((0.305)*x496))+(((0.35)*cj1)));
evalcond[4]=((((0.005263)*x498))+(((0.005263)*x496))+(((-0.35)*sj1))+(((-1.0)*px*x491))+(((0.305)*x497))+(((-1.0)*py*sj0))+(((-0.305)*x495)));
evalcond[5]=((((-1.0)*r01*sj4*sj5*x491))+((r10*sj4*x494))+(((-1.0)*r11*x490*x492))+(((-1.0)*x499))+((r00*sj4*x493))+((cj0*cj4*r02))+x495+((cj4*r12*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x500=(cj4*r22);
IkReal x501=(r22*sj4);
IkReal x502=(cj5*r20*sj4);
IkReal x503=(r21*sj1*sj5);
IkReal x504=(cj4*cj5*r20);
IkReal x505=((1.0)*cj1*r21*sj5);
if( IKabs((((cj1*x504))+(((-1.0)*sj4*x503))+(((-1.0)*cj4*x505))+((sj1*x502))+((sj1*x500))+(((-1.0)*cj1*x501)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x502))+((cj1*x500))+(((-1.0)*sj1*x504))+(((-1.0)*sj4*x505))+((sj1*x501))+((cj4*x503)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x504))+(((-1.0)*sj4*x503))+(((-1.0)*cj4*x505))+((sj1*x502))+((sj1*x500))+(((-1.0)*cj1*x501))))+IKsqr((((cj1*x502))+((cj1*x500))+(((-1.0)*sj1*x504))+(((-1.0)*sj4*x505))+((sj1*x501))+((cj4*x503))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj1*x504))+(((-1.0)*sj4*x503))+(((-1.0)*cj4*x505))+((sj1*x502))+((sj1*x500))+(((-1.0)*cj1*x501))), (((cj1*x502))+((cj1*x500))+(((-1.0)*sj1*x504))+(((-1.0)*sj4*x505))+((sj1*x501))+((cj4*x503))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x506=IKcos(j2);
IkReal x507=IKsin(j2);
IkReal x508=(cj0*cj4);
IkReal x509=(cj5*r00);
IkReal x510=((1.0)*sj5);
IkReal x511=(sj0*sj4);
IkReal x512=(cj0*sj4);
IkReal x513=(cj5*r10);
IkReal x514=(cj4*sj0);
IkReal x515=(cj5*r20);
IkReal x516=(sj1*x506);
IkReal x517=(cj1*x506);
IkReal x518=(cj1*x507);
IkReal x519=(sj1*x507);
IkReal x520=((1.0)*x518);
evalcond[0]=(((sj4*x515))+((cj4*r22))+(((-1.0)*x519))+(((-1.0)*x517))+(((-1.0)*r21*sj4*x510)));
evalcond[1]=((((-1.0)*cj4*r21*x510))+((cj4*x515))+(((-1.0)*x520))+x516+(((-1.0)*r22*sj4)));
evalcond[2]=((((0.305)*x517))+(((0.305)*x519))+(((1.0e-8)*x516))+(((-1.0)*pz))+(((-1.0e-8)*x518))+(((0.35)*cj1)));
evalcond[3]=((((0.305)*x518))+(((1.0e-8)*x519))+(((1.0e-8)*x517))+(((-0.35)*sj1))+(((-0.305)*x516))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px)));
evalcond[4]=(((x511*x513))+(((-1.0)*r01*x510*x512))+(((-1.0)*x520))+x516+(((-1.0)*r11*x510*x511))+((x509*x512))+((r12*x514))+((r02*x508)));
evalcond[5]=((((-1.0)*r12*x511))+((x508*x509))+((x513*x514))+(((-1.0)*r02*x512))+x519+x517+(((-1.0)*r11*x510*x514))+(((-1.0)*r01*x508*x510)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x521=((1.0)*sj4);
IkReal x522=(r22*sj1);
IkReal x523=(cj1*cj4);
IkReal x524=(cj5*r20);
IkReal x525=(cj1*r21*sj5);
IkReal x526=(sj4*x524);
IkReal x527=(r21*sj1*sj5);
if( IKabs((((cj4*x522))+((sj1*x526))+(((-1.0)*x521*x527))+((r21*sj5*x523))+((cj1*r22*sj4))+(((-1.0)*x523*x524)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x521*x525))+(((-1.0)*x521*x522))+((r22*x523))+((cj1*x526))+((cj4*sj1*x524))+(((-1.0)*cj4*x527)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj4*x522))+((sj1*x526))+(((-1.0)*x521*x527))+((r21*sj5*x523))+((cj1*r22*sj4))+(((-1.0)*x523*x524))))+IKsqr(((((-1.0)*x521*x525))+(((-1.0)*x521*x522))+((r22*x523))+((cj1*x526))+((cj4*sj1*x524))+(((-1.0)*cj4*x527))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2((((cj4*x522))+((sj1*x526))+(((-1.0)*x521*x527))+((r21*sj5*x523))+((cj1*r22*sj4))+(((-1.0)*x523*x524))), ((((-1.0)*x521*x525))+(((-1.0)*x521*x522))+((r22*x523))+((cj1*x526))+((cj4*sj1*x524))+(((-1.0)*cj4*x527))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[6];
IkReal x528=IKsin(j2);
IkReal x529=IKcos(j2);
IkReal x530=(cj0*cj4);
IkReal x531=(cj5*r00);
IkReal x532=((1.0)*sj5);
IkReal x533=(sj0*sj4);
IkReal x534=(cj0*sj4);
IkReal x535=(cj5*r10);
IkReal x536=(cj4*sj0);
IkReal x537=(cj5*r20);
IkReal x538=(cj1*x528);
IkReal x539=((1.0)*x529);
IkReal x540=(sj1*x528);
IkReal x541=((0.305)*x529);
IkReal x542=(sj1*x529);
IkReal x543=((1.0)*x540);
IkReal x544=(cj1*x539);
IkReal x545=(x544+x543);
evalcond[0]=(((cj4*r22))+(((-1.0)*x545))+(((-1.0)*r21*sj4*x532))+((sj4*x537)));
evalcond[1]=(((cj4*x537))+(((-1.0)*sj1*x539))+x538+(((-1.0)*r22*sj4))+(((-1.0)*cj4*r21*x532)));
evalcond[2]=(((cj1*x541))+(((-1.0)*pz))+(((-1.0e-8)*x542))+(((0.305)*x540))+(((1.0e-8)*x538))+(((0.35)*cj1)));
evalcond[3]=((((-1.0)*sj1*x541))+(((-1.0e-8)*cj1*x529))+(((-0.35)*sj1))+(((-1.0e-8)*x540))+(((-1.0)*py*sj0))+(((0.305)*x538))+(((-1.0)*cj0*px)));
evalcond[4]=(((r02*x530))+(((-1.0)*r11*x532*x533))+(((-1.0)*x538))+((r12*x536))+((x531*x534))+(((-1.0)*r01*x532*x534))+x542+((x533*x535)));
evalcond[5]=((((-1.0)*r02*x534))+(((-1.0)*r11*x532*x536))+(((-1.0)*r01*x530*x532))+(((-1.0)*x545))+(((-1.0)*r12*x533))+((x535*x536))+((x530*x531)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x546=(cj1*cj4);
IkReal x547=(cj3*r22);
IkReal x548=(cj4*sj1);
IkReal x549=(cj5*r20);
IkReal x550=(sj1*sj4);
IkReal x551=(cj1*sj4);
IkReal x552=((1.0)*r21*sj5);
CheckValue<IkReal> x553=IKPowWithIntegerCheck(IKsign(cj3),-1);
if(!x553.valid){
continue;
}
CheckValue<IkReal> x554 = IKatan2WithCheck(IkReal(((((-1.0)*r22*x551))+((x547*x548))+((cj3*x549*x550))+(((-1.0)*cj3*x550*x552))+(((-1.0)*x546*x552))+((x546*x549)))),IkReal(((((-1.0)*cj3*x551*x552))+((cj3*x549*x551))+((r21*sj5*x548))+(((-1.0)*x548*x549))+((r22*x550))+((x546*x547)))),IKFAST_ATAN2_MAGTHRESH);
if(!x554.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x553.value)))+(x554.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x555=IKsin(j2);
IkReal x556=IKcos(j2);
IkReal x557=(sj0*sj5);
IkReal x558=(cj0*cj4);
IkReal x559=(cj5*r00);
IkReal x560=((1.0)*cj0);
IkReal x561=((1.0)*sj4);
IkReal x562=((1.0e-8)*cj3);
IkReal x563=((0.005263)*sj3);
IkReal x564=(r01*sj5);
IkReal x565=(cj5*sj0);
IkReal x566=(r12*sj0);
IkReal x567=((1.0)*sj3);
IkReal x568=((1.0)*cj4);
IkReal x569=(r21*sj5);
IkReal x570=(cj5*r20);
IkReal x571=(cj1*x555);
IkReal x572=(cj1*x556);
IkReal x573=(sj1*x555);
IkReal x574=(sj1*x556);
evalcond[0]=(((cj5*r21))+((sj3*x571))+(((-1.0)*x567*x574))+((r20*sj5)));
evalcond[1]=(((sj4*x570))+((cj4*r22))+(((-1.0)*x572))+(((-1.0)*x573))+(((-1.0)*x561*x569)));
evalcond[2]=((((-1.0)*cj3*x571))+((cj3*x574))+(((-1.0)*x568*x569))+(((-1.0)*r22*x561))+((cj4*x570)));
evalcond[3]=(((cj0*cj5*r01))+((r10*x557))+((cj0*r00*sj5))+(((-1.0)*x567*x573))+(((-1.0)*x567*x572))+((r11*x565)));
evalcond[4]=((((-1.0)*sj4*x560*x564))+((cj0*sj4*x559))+((r02*x558))+((r10*sj4*x565))+(((-1.0)*x571))+x574+(((-1.0)*r11*x557*x561))+((cj4*x566)));
evalcond[5]=((((-1.0)*x558*x564))+((cj3*x573))+((cj3*x572))+((cj4*r10*x565))+((x558*x559))+(((-1.0)*r02*sj4*x560))+(((-1.0)*r11*x557*x568))+(((-1.0)*x561*x566)));
evalcond[6]=((((0.305)*x573))+(((0.305)*x572))+((x563*x571))+((x562*x574))+(((-1.0)*pz))+(((-1.0)*x563*x574))+(((0.35)*cj1))+(((-1.0)*x562*x571)));
evalcond[7]=((((0.305)*x571))+(((-0.35)*sj1))+((x562*x572))+((x562*x573))+(((-1.0)*x563*x573))+(((-1.0)*x563*x572))+(((-0.305)*x574))+(((-1.0)*py*sj0))+(((-1.0)*px*x560)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x575=((1.0)*cj1);
IkReal x576=(cj5*r21);
IkReal x577=(sj0*sj1);
IkReal x578=(cj5*r11);
IkReal x579=(r20*sj5);
IkReal x580=(r10*sj5);
IkReal x581=(cj1*sj0);
IkReal x582=(cj0*cj5*r01);
IkReal x583=(cj0*r00*sj5);
CheckValue<IkReal> x584=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x584.valid){
continue;
}
CheckValue<IkReal> x585 = IKatan2WithCheck(IkReal((((x577*x580))+((sj1*x583))+((sj1*x582))+(((-1.0)*x575*x579))+(((-1.0)*x575*x576))+((x577*x578)))),IkReal((((x578*x581))+((sj1*x576))+((sj1*x579))+((x580*x581))+((cj1*x582))+((cj1*x583)))),IKFAST_ATAN2_MAGTHRESH);
if(!x585.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x584.value)))+(x585.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x586=IKsin(j2);
IkReal x587=IKcos(j2);
IkReal x588=(sj0*sj5);
IkReal x589=(cj0*cj4);
IkReal x590=(cj5*r00);
IkReal x591=((1.0)*cj0);
IkReal x592=((1.0)*sj4);
IkReal x593=((1.0e-8)*cj3);
IkReal x594=((0.005263)*sj3);
IkReal x595=(r01*sj5);
IkReal x596=(cj5*sj0);
IkReal x597=(r12*sj0);
IkReal x598=((1.0)*sj3);
IkReal x599=((1.0)*cj4);
IkReal x600=(r21*sj5);
IkReal x601=(cj5*r20);
IkReal x602=(cj1*x586);
IkReal x603=(cj1*x587);
IkReal x604=(sj1*x586);
IkReal x605=(sj1*x587);
evalcond[0]=(((cj5*r21))+(((-1.0)*x598*x605))+((r20*sj5))+((sj3*x602)));
evalcond[1]=((((-1.0)*x592*x600))+((cj4*r22))+((sj4*x601))+(((-1.0)*x604))+(((-1.0)*x603)));
evalcond[2]=(((cj3*x605))+(((-1.0)*x599*x600))+(((-1.0)*r22*x592))+(((-1.0)*cj3*x602))+((cj4*x601)));
evalcond[3]=(((cj0*cj5*r01))+((r10*x588))+(((-1.0)*x598*x603))+(((-1.0)*x598*x604))+((r11*x596))+((cj0*r00*sj5)));
evalcond[4]=((((-1.0)*r11*x588*x592))+((r10*sj4*x596))+(((-1.0)*sj4*x591*x595))+((r02*x589))+((cj0*sj4*x590))+(((-1.0)*x602))+x605+((cj4*x597)));
evalcond[5]=(((cj4*r10*x596))+(((-1.0)*r11*x588*x599))+(((-1.0)*x589*x595))+(((-1.0)*r02*sj4*x591))+((cj3*x603))+((cj3*x604))+(((-1.0)*x592*x597))+((x589*x590)));
evalcond[6]=((((-1.0)*x593*x602))+((x594*x602))+((x593*x605))+(((0.305)*x603))+(((0.305)*x604))+(((-1.0)*pz))+(((-1.0)*x594*x605))+(((0.35)*cj1)));
evalcond[7]=((((-1.0)*px*x591))+((x593*x603))+((x593*x604))+(((-0.35)*sj1))+(((0.305)*x602))+(((-1.0)*py*sj0))+(((-0.305)*x605))+(((-1.0)*x594*x603))+(((-1.0)*x594*x604)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x606=(sj3*sj4);
IkReal x607=(r20*sj5);
IkReal x608=(cj5*r20);
IkReal x609=(r21*sj1);
IkReal x610=((1.0)*cj1*r21);
IkReal x611=(cj4*r22*sj3);
CheckValue<IkReal> x612=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x612.valid){
continue;
}
CheckValue<IkReal> x613 = IKatan2WithCheck(IkReal((((sj1*x611))+((sj1*x606*x608))+(((-1.0)*cj1*x607))+(((-1.0)*cj5*x610))+(((-1.0)*sj5*x606*x609)))),IkReal((((cj5*x609))+((sj1*x607))+(((-1.0)*sj5*x606*x610))+((cj1*x611))+((cj1*x606*x608)))),IKFAST_ATAN2_MAGTHRESH);
if(!x613.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x612.value)))+(x613.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[8];
IkReal x614=IKsin(j2);
IkReal x615=IKcos(j2);
IkReal x616=(sj0*sj5);
IkReal x617=(cj0*cj4);
IkReal x618=(cj5*r00);
IkReal x619=((1.0)*cj0);
IkReal x620=((1.0)*sj4);
IkReal x621=((1.0e-8)*cj3);
IkReal x622=((0.005263)*sj3);
IkReal x623=(r01*sj5);
IkReal x624=(cj5*sj0);
IkReal x625=(r12*sj0);
IkReal x626=((1.0)*sj3);
IkReal x627=((1.0)*cj4);
IkReal x628=(r21*sj5);
IkReal x629=(cj5*r20);
IkReal x630=(cj1*x614);
IkReal x631=(cj1*x615);
IkReal x632=(sj1*x614);
IkReal x633=(sj1*x615);
evalcond[0]=(((cj5*r21))+((sj3*x630))+(((-1.0)*x626*x633))+((r20*sj5)));
evalcond[1]=(((sj4*x629))+((cj4*r22))+(((-1.0)*x620*x628))+(((-1.0)*x632))+(((-1.0)*x631)));
evalcond[2]=(((cj3*x633))+((cj4*x629))+(((-1.0)*cj3*x630))+(((-1.0)*x627*x628))+(((-1.0)*r22*x620)));
evalcond[3]=(((cj0*cj5*r01))+((cj0*r00*sj5))+(((-1.0)*x626*x632))+(((-1.0)*x626*x631))+((r10*x616))+((r11*x624)));
evalcond[4]=((((-1.0)*r11*x616*x620))+(((-1.0)*sj4*x619*x623))+((cj0*sj4*x618))+((cj4*x625))+((r02*x617))+x633+((r10*sj4*x624))+(((-1.0)*x630)));
evalcond[5]=((((-1.0)*r11*x616*x627))+((cj3*x632))+((cj3*x631))+(((-1.0)*r02*sj4*x619))+(((-1.0)*x620*x625))+((x617*x618))+((cj4*r10*x624))+(((-1.0)*x617*x623)));
evalcond[6]=((((-1.0)*x621*x630))+(((-1.0)*x622*x633))+(((-1.0)*pz))+((x621*x633))+(((0.305)*x631))+(((0.305)*x632))+((x622*x630))+(((0.35)*cj1)));
evalcond[7]=((((-0.305)*x633))+(((-1.0)*x622*x632))+(((-1.0)*x622*x631))+(((-0.35)*sj1))+(((-1.0)*py*sj0))+((x621*x631))+((x621*x632))+(((0.305)*x630))+(((-1.0)*px*x619)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x634=((1.0e-8)*cj3);
IkReal x635=(cj5*r21);
IkReal x636=(sj1*sj3);
IkReal x637=(cj0*px);
IkReal x638=(py*sj0);
IkReal x639=((0.005263)*sj3);
IkReal x640=(cj1*sj3);
IkReal x641=((0.35)*sj3);
IkReal x642=(r20*sj5);
IkReal x643=((0.305)*sj1);
IkReal x644=(cj1*x642);
CheckValue<IkReal> x645 = IKatan2WithCheck(IkReal((((x635*x643))+(((-1.0)*cj1*x634*x635))+((x639*x644))+((x636*x637))+((x636*x638))+(((-0.35)*cj1*x640))+x641+((cj1*x635*x639))+(((-1.0)*x634*x644))+((x642*x643)))),IkReal((((x638*x640))+(((0.305)*x644))+(((0.35)*cj1*x636))+((x637*x640))+(((0.305)*cj1*x635))+((sj1*x634*x635))+(((-0.005263)*x636*x642))+((sj1*x634*x642))+(((-0.005263)*x635*x636)))),IKFAST_ATAN2_MAGTHRESH);
if(!x645.valid){
continue;
}
CheckValue<IkReal> x646=IKPowWithIntegerCheck(IKsign(((-0.005263)+((sj3*x634))+(((0.005263)*(cj3*cj3))))),-1);
if(!x646.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x645.value)+(((1.5707963267949)*(x646.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x647=IKcos(j2);
IkReal x648=IKsin(j2);
IkReal x649=((0.005263)*sj3);
IkReal x650=((1.0e-8)*cj3);
IkReal x651=((1.0)*sj3);
IkReal x652=(cj1*x648);
IkReal x653=(sj1*x648);
IkReal x654=(cj1*x647);
IkReal x655=(sj1*x647);
evalcond[0]=(((cj5*r21))+(((-1.0)*x651*x655))+((sj3*x652))+((r20*sj5)));
evalcond[1]=(((cj0*cj5*r01))+(((-1.0)*x651*x653))+(((-1.0)*x651*x654))+((cj5*r11*sj0))+((cj0*r00*sj5))+((r10*sj0*sj5)));
evalcond[2]=((((0.305)*x653))+(((0.305)*x654))+((x649*x652))+(((-1.0)*pz))+(((-1.0)*x650*x652))+(((-1.0)*x649*x655))+((x650*x655))+(((0.35)*cj1)));
evalcond[3]=((((0.305)*x652))+(((-0.305)*x655))+(((-0.35)*sj1))+(((-1.0)*py*sj0))+(((-1.0)*x649*x654))+(((-1.0)*x649*x653))+((x650*x653))+((x650*x654))+(((-1.0)*cj0*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[2];
IkReal x656=(((cj0*cj5*r01))+((cj5*r11*sj0))+((cj0*r00*sj5))+((r10*sj0*sj5)));
j4eval[0]=x656;
j4eval[1]=IKsign(x656);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x657=cj5*cj5;
IkReal x658=r21*r21;
IkReal x659=((r22*r22)+((x657*(r20*r20)))+(((-2.0)*cj5*r20*r21*sj5))+x658+(((-1.0)*x657*x658)));
j4eval[0]=x659;
j4eval[1]=IKsign(x659);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x660=cj5*cj5;
IkReal x661=(cj0*r11);
IkReal x662=((1.0)*sj0);
IkReal x663=(cj0*r10);
IkReal x664=(cj5*r20*sj5);
IkReal x665=(r21*x660);
IkReal x666=(cj5*r21*sj5);
IkReal x667=(r20*x660);
IkReal x668=((((-1.0)*r21*x661))+((r00*sj0*x667))+(((-1.0)*r01*x662*x665))+(((-1.0)*r01*x662*x664))+((x663*x666))+(((-1.0)*x663*x667))+((r01*r21*sj0))+(((-1.0)*cj0*r12*r22))+((x661*x664))+((x661*x665))+((r02*r22*sj0))+(((-1.0)*r00*x662*x666)));
j4eval[0]=x668;
j4eval[1]=IKsign(x668);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x669=cj5*cj5;
IkReal x670=((1.0)*sj5);
IkReal x671=(cj5*r10);
IkReal x672=(cj0*r11);
IkReal x673=(r02*sj0);
IkReal x674=((1.0)*cj0);
IkReal x675=(r01*sj0);
IkReal x676=((1.0)*x675);
IkReal x677=(r21*x669);
IkReal x678=(cj5*r20*sj5);
IkReal x679=(cj5*r00*sj0);
IkReal x680=(cj2*cj3*sj1);
IkReal x681=(cj1*cj3*sj2);
IkReal x682=(r20*x669);
IkReal x683=(cj0*x680);
CheckValue<IkReal> x684=IKPowWithIntegerCheck(IKsign((((r21*x675))+((x672*x677))+((x672*x678))+((r22*x673))+(((-1.0)*r21*x670*x679))+(((-1.0)*r10*x674*x682))+(((-1.0)*r21*x672))+(((-1.0)*r12*r22*x674))+(((-1.0)*x676*x677))+((r00*sj0*x682))+(((-1.0)*cj5*r20*x670*x675))+((cj0*r21*sj5*x671)))),-1);
if(!x684.valid){
continue;
}
CheckValue<IkReal> x685 = IKatan2WithCheck(IkReal(((((-1.0)*x673*x681))+((x673*x680))+((cj0*r12*x681))+(((-1.0)*r12*x674*x680)))),IkReal(((((-1.0)*x670*x675*x681))+((sj5*x672*x681))+(((-1.0)*x670*x672*x680))+((sj5*x675*x680))+((x671*x683))+(((-1.0)*x671*x674*x681))+((x679*x681))+(((-1.0)*x679*x680)))),IKFAST_ATAN2_MAGTHRESH);
if(!x685.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x684.value)))+(x685.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x686=IKsin(j4);
IkReal x687=IKcos(j4);
IkReal x688=(r12*sj0);
IkReal x689=(r01*sj5);
IkReal x690=(cj0*r02);
IkReal x691=(cj1*cj2);
IkReal x692=(cj3*sj1);
IkReal x693=((1.0)*sj2);
IkReal x694=(r02*sj0);
IkReal x695=(cj5*r10);
IkReal x696=(cj0*r00);
IkReal x697=(r11*sj5);
IkReal x698=(r21*sj5);
IkReal x699=(r00*sj0);
IkReal x700=((1.0)*x686);
IkReal x701=(cj5*x686);
IkReal x702=(cj0*x686);
IkReal x703=((1.0)*x687);
IkReal x704=(cj5*x687);
IkReal x705=(cj0*x703);
evalcond[0]=((((-1.0)*sj1*x693))+((r22*x687))+((r20*x701))+(((-1.0)*x698*x700))+(((-1.0)*x691)));
evalcond[1]=((((-1.0)*cj1*cj3*x693))+((r20*x704))+(((-1.0)*x698*x703))+((cj2*x692))+(((-1.0)*r22*x700)));
evalcond[2]=((((-1.0)*r12*x705))+((x687*x694))+((x697*x702))+(((-1.0)*sj0*x689*x700))+(((-1.0)*cj0*x695*x700))+((x699*x701)));
evalcond[3]=((((-1.0)*sj3))+((cj0*x687*x697))+(((-1.0)*x694*x700))+(((-1.0)*x695*x705))+(((-1.0)*sj0*x689*x703))+((r12*x702))+((x699*x704)));
evalcond[4]=(((cj2*sj1))+((x687*x688))+((x687*x690))+(((-1.0)*cj1*x693))+((sj0*x686*x695))+((x696*x701))+(((-1.0)*sj0*x697*x700))+(((-1.0)*cj0*x689*x700)));
evalcond[5]=((((-1.0)*x689*x705))+(((-1.0)*x690*x700))+(((-1.0)*x688*x700))+((cj3*x691))+((x696*x704))+((sj2*x692))+(((-1.0)*sj0*x697*x703))+((sj0*x687*x695)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x706=cj5*cj5;
IkReal x707=r21*r21;
IkReal x708=((1.0)*cj3);
IkReal x709=(r22*sj2);
IkReal x710=(sj1*sj2);
IkReal x711=(cj1*cj2);
IkReal x712=(r21*sj5);
IkReal x713=(cj5*r20);
IkReal x714=(cj1*sj2);
IkReal x715=(cj2*x713);
IkReal x716=((1.0)*x712);
IkReal x717=(cj2*cj3*sj1);
CheckValue<IkReal> x718=IKPowWithIntegerCheck(IKsign(((((-1.0)*x706*x707))+(((-2.0)*x712*x713))+(r22*r22)+x707+((x706*(r20*r20))))),-1);
if(!x718.valid){
continue;
}
CheckValue<IkReal> x719 = IKatan2WithCheck(IkReal((((r22*x717))+(((-1.0)*x711*x716))+(((-1.0)*x710*x716))+((x711*x713))+((x710*x713))+(((-1.0)*cj1*x708*x709)))),IkReal((((r22*x711))+((cj3*x713*x714))+(((-1.0)*sj1*x708*x715))+(((-1.0)*x708*x712*x714))+((sj1*x709))+((x712*x717)))),IKFAST_ATAN2_MAGTHRESH);
if(!x719.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x718.value)))+(x719.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x720=IKsin(j4);
IkReal x721=IKcos(j4);
IkReal x722=(r12*sj0);
IkReal x723=(r01*sj5);
IkReal x724=(cj0*r02);
IkReal x725=(cj1*cj2);
IkReal x726=(cj3*sj1);
IkReal x727=((1.0)*sj2);
IkReal x728=(r02*sj0);
IkReal x729=(cj5*r10);
IkReal x730=(cj0*r00);
IkReal x731=(r11*sj5);
IkReal x732=(r21*sj5);
IkReal x733=(r00*sj0);
IkReal x734=((1.0)*x720);
IkReal x735=(cj5*x720);
IkReal x736=(cj0*x720);
IkReal x737=((1.0)*x721);
IkReal x738=(cj5*x721);
IkReal x739=(cj0*x737);
evalcond[0]=((((-1.0)*x732*x734))+((r20*x735))+(((-1.0)*x725))+(((-1.0)*sj1*x727))+((r22*x721)));
evalcond[1]=((((-1.0)*x732*x737))+((r20*x738))+(((-1.0)*cj1*cj3*x727))+((cj2*x726))+(((-1.0)*r22*x734)));
evalcond[2]=(((x721*x728))+((x731*x736))+(((-1.0)*cj0*x729*x734))+((x733*x735))+(((-1.0)*sj0*x723*x734))+(((-1.0)*r12*x739)));
evalcond[3]=(((r12*x736))+(((-1.0)*sj3))+((x733*x738))+((cj0*x721*x731))+(((-1.0)*sj0*x723*x737))+(((-1.0)*x728*x734))+(((-1.0)*x729*x739)));
evalcond[4]=(((x721*x724))+((x721*x722))+((cj2*sj1))+((sj0*x720*x729))+(((-1.0)*cj1*x727))+(((-1.0)*cj0*x723*x734))+(((-1.0)*sj0*x731*x734))+((x730*x735)));
evalcond[5]=((((-1.0)*x723*x739))+(((-1.0)*x724*x734))+(((-1.0)*x722*x734))+((sj2*x726))+((cj3*x725))+((sj0*x721*x729))+(((-1.0)*sj0*x731*x737))+((x730*x738)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x740=(cj1*cj2);
IkReal x741=(cj5*sj0);
IkReal x742=(sj1*sj2);
IkReal x743=(cj0*r12);
IkReal x744=(cj0*cj5);
IkReal x745=((1.0)*r10);
IkReal x746=(sj0*sj5);
IkReal x747=((1.0)*r01);
IkReal x748=(cj0*r11*sj5);
IkReal x749=((1.0)*r02*sj0);
CheckValue<IkReal> x750 = IKatan2WithCheck(IkReal((((x742*x743))+(((-1.0)*x742*x749))+((x740*x743))+(((-1.0)*x740*x749)))),IkReal((((x742*x748))+((r00*x740*x741))+(((-1.0)*x742*x746*x747))+(((-1.0)*x740*x746*x747))+(((-1.0)*x740*x744*x745))+((x740*x748))+(((-1.0)*x742*x744*x745))+((r00*x741*x742)))),IKFAST_ATAN2_MAGTHRESH);
if(!x750.valid){
continue;
}
CheckValue<IkReal> x751=IKPowWithIntegerCheck(IKsign((((r10*x746))+((r11*x741))+((cj0*r00*sj5))+((r01*x744)))),-1);
if(!x751.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x750.value)+(((1.5707963267949)*(x751.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x752=IKsin(j4);
IkReal x753=IKcos(j4);
IkReal x754=(r12*sj0);
IkReal x755=(r01*sj5);
IkReal x756=(cj0*r02);
IkReal x757=(cj1*cj2);
IkReal x758=(cj3*sj1);
IkReal x759=((1.0)*sj2);
IkReal x760=(r02*sj0);
IkReal x761=(cj5*r10);
IkReal x762=(cj0*r00);
IkReal x763=(r11*sj5);
IkReal x764=(r21*sj5);
IkReal x765=(r00*sj0);
IkReal x766=((1.0)*x752);
IkReal x767=(cj5*x752);
IkReal x768=(cj0*x752);
IkReal x769=((1.0)*x753);
IkReal x770=(cj5*x753);
IkReal x771=(cj0*x769);
evalcond[0]=((((-1.0)*sj1*x759))+((r20*x767))+((r22*x753))+(((-1.0)*x764*x766))+(((-1.0)*x757)));
evalcond[1]=((((-1.0)*x764*x769))+((cj2*x758))+((r20*x770))+(((-1.0)*cj1*cj3*x759))+(((-1.0)*r22*x766)));
evalcond[2]=((((-1.0)*cj0*x761*x766))+(((-1.0)*r12*x771))+((x763*x768))+((x765*x767))+(((-1.0)*sj0*x755*x766))+((x753*x760)));
evalcond[3]=((((-1.0)*sj3))+((cj0*x753*x763))+((x765*x770))+(((-1.0)*sj0*x755*x769))+((r12*x768))+(((-1.0)*x760*x766))+(((-1.0)*x761*x771)));
evalcond[4]=(((cj2*sj1))+((x762*x767))+((sj0*x752*x761))+(((-1.0)*cj1*x759))+((x753*x756))+((x753*x754))+(((-1.0)*sj0*x763*x766))+(((-1.0)*cj0*x755*x766)));
evalcond[5]=((((-1.0)*x756*x766))+(((-1.0)*x755*x771))+(((-1.0)*x754*x766))+((cj3*x757))+((x762*x770))+((sj0*x753*x761))+((sj2*x758))+(((-1.0)*sj0*x763*x769)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x772=((1.0)*cj1);
IkReal x773=(cj5*r21);
IkReal x774=(sj0*sj1);
IkReal x775=(cj5*r11);
IkReal x776=(r20*sj5);
IkReal x777=(r10*sj5);
IkReal x778=(cj1*sj0);
IkReal x779=(cj0*cj5*r01);
IkReal x780=(cj0*r00*sj5);
CheckValue<IkReal> x781=IKPowWithIntegerCheck(IKsign(sj3),-1);
if(!x781.valid){
continue;
}
CheckValue<IkReal> x782 = IKatan2WithCheck(IkReal((((x774*x777))+((x774*x775))+((sj1*x780))+((sj1*x779))+(((-1.0)*x772*x773))+(((-1.0)*x772*x776)))),IkReal((((x777*x778))+((cj1*x780))+((cj1*x779))+((sj1*x776))+((sj1*x773))+((x775*x778)))),IKFAST_ATAN2_MAGTHRESH);
if(!x782.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x781.value)))+(x782.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[4];
IkReal x783=IKcos(j2);
IkReal x784=IKsin(j2);
IkReal x785=((0.005263)*sj3);
IkReal x786=((1.0e-8)*cj3);
IkReal x787=((1.0)*sj3);
IkReal x788=(cj1*x784);
IkReal x789=(sj1*x784);
IkReal x790=(cj1*x783);
IkReal x791=(sj1*x783);
evalcond[0]=(((cj5*r21))+(((-1.0)*x787*x791))+((sj3*x788))+((r20*sj5)));
evalcond[1]=(((cj0*cj5*r01))+((cj5*r11*sj0))+(((-1.0)*x787*x790))+(((-1.0)*x787*x789))+((cj0*r00*sj5))+((r10*sj0*sj5)));
evalcond[2]=(((x786*x791))+((x785*x788))+(((0.305)*x790))+(((0.305)*x789))+(((-1.0)*pz))+(((-1.0)*x786*x788))+(((-1.0)*x785*x791))+(((0.35)*cj1)));
evalcond[3]=(((x786*x789))+((x786*x790))+(((-0.305)*x791))+(((0.305)*x788))+(((-0.35)*sj1))+(((-1.0)*py*sj0))+(((-1.0)*x785*x790))+(((-1.0)*x785*x789))+(((-1.0)*cj0*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[2];
IkReal x792=(((cj0*cj5*r01))+((cj5*r11*sj0))+((cj0*r00*sj5))+((r10*sj0*sj5)));
j4eval[0]=x792;
j4eval[1]=IKsign(x792);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x793=cj5*cj5;
IkReal x794=r21*r21;
IkReal x795=((r22*r22)+(((-1.0)*x793*x794))+(((-2.0)*cj5*r20*r21*sj5))+x794+((x793*(r20*r20))));
j4eval[0]=x795;
j4eval[1]=IKsign(x795);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
IkReal x796=cj5*cj5;
IkReal x797=(cj0*r11);
IkReal x798=((1.0)*sj0);
IkReal x799=(cj0*r10);
IkReal x800=(cj5*r20*sj5);
IkReal x801=(r21*x796);
IkReal x802=(cj5*r21*sj5);
IkReal x803=(r20*x796);
IkReal x804=((((-1.0)*r01*x798*x800))+(((-1.0)*r01*x798*x801))+(((-1.0)*r21*x797))+(((-1.0)*x799*x803))+((x797*x800))+((x797*x801))+(((-1.0)*r00*x798*x802))+((r01*r21*sj0))+((r00*sj0*x803))+((x799*x802))+(((-1.0)*cj0*r12*r22))+((r02*r22*sj0)));
j4eval[0]=x804;
j4eval[1]=IKsign(x804);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x805=cj5*cj5;
IkReal x806=((1.0)*sj5);
IkReal x807=(cj5*r10);
IkReal x808=(cj0*r11);
IkReal x809=(r02*sj0);
IkReal x810=((1.0)*cj0);
IkReal x811=(r01*sj0);
IkReal x812=((1.0)*x811);
IkReal x813=(r21*x805);
IkReal x814=(cj5*r20*sj5);
IkReal x815=(cj5*r00*sj0);
IkReal x816=(cj2*cj3*sj1);
IkReal x817=(cj1*cj3*sj2);
IkReal x818=(r20*x805);
IkReal x819=(cj0*x816);
CheckValue<IkReal> x820 = IKatan2WithCheck(IkReal((((cj0*r12*x817))+((x809*x816))+(((-1.0)*r12*x810*x816))+(((-1.0)*x809*x817)))),IkReal((((x815*x817))+((sj5*x808*x817))+(((-1.0)*x815*x816))+(((-1.0)*x806*x811*x817))+((sj5*x811*x816))+((x807*x819))+(((-1.0)*x806*x808*x816))+(((-1.0)*x807*x810*x817)))),IKFAST_ATAN2_MAGTHRESH);
if(!x820.valid){
continue;
}
CheckValue<IkReal> x821=IKPowWithIntegerCheck(IKsign(((((-1.0)*x812*x813))+(((-1.0)*r21*x808))+((x808*x813))+((x808*x814))+((r22*x809))+((cj0*r21*sj5*x807))+(((-1.0)*cj5*r20*x806*x811))+(((-1.0)*r12*r22*x810))+((r21*x811))+(((-1.0)*r10*x810*x818))+((r00*sj0*x818))+(((-1.0)*r21*x806*x815)))),-1);
if(!x821.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x820.value)+(((1.5707963267949)*(x821.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x822=IKsin(j4);
IkReal x823=IKcos(j4);
IkReal x824=(r12*sj0);
IkReal x825=(r01*sj5);
IkReal x826=(cj0*r02);
IkReal x827=(cj1*cj2);
IkReal x828=(cj3*sj1);
IkReal x829=((1.0)*sj2);
IkReal x830=(r02*sj0);
IkReal x831=(cj5*r10);
IkReal x832=(cj0*r00);
IkReal x833=(r11*sj5);
IkReal x834=(r21*sj5);
IkReal x835=(r00*sj0);
IkReal x836=((1.0)*x822);
IkReal x837=(cj5*x822);
IkReal x838=(cj0*x822);
IkReal x839=((1.0)*x823);
IkReal x840=(cj5*x823);
IkReal x841=(cj0*x839);
evalcond[0]=(((r20*x837))+(((-1.0)*x834*x836))+(((-1.0)*x827))+((r22*x823))+(((-1.0)*sj1*x829)));
evalcond[1]=(((r20*x840))+(((-1.0)*x834*x839))+(((-1.0)*cj1*cj3*x829))+(((-1.0)*r22*x836))+((cj2*x828)));
evalcond[2]=(((x833*x838))+((x835*x837))+(((-1.0)*sj0*x825*x836))+((x823*x830))+(((-1.0)*cj0*x831*x836))+(((-1.0)*r12*x841)));
evalcond[3]=((((-1.0)*x831*x841))+(((-1.0)*sj3))+((x835*x840))+(((-1.0)*x830*x836))+((cj0*x823*x833))+(((-1.0)*sj0*x825*x839))+((r12*x838)));
evalcond[4]=(((cj2*sj1))+((x832*x837))+((sj0*x822*x831))+(((-1.0)*sj0*x833*x836))+((x823*x824))+((x823*x826))+(((-1.0)*cj0*x825*x836))+(((-1.0)*cj1*x829)));
evalcond[5]=((((-1.0)*x826*x836))+((sj0*x823*x831))+((x832*x840))+((sj2*x828))+(((-1.0)*x824*x836))+(((-1.0)*sj0*x833*x839))+(((-1.0)*x825*x841))+((cj3*x827)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x842=cj5*cj5;
IkReal x843=r21*r21;
IkReal x844=((1.0)*cj3);
IkReal x845=(r22*sj2);
IkReal x846=(sj1*sj2);
IkReal x847=(cj1*cj2);
IkReal x848=(r21*sj5);
IkReal x849=(cj5*r20);
IkReal x850=(cj1*sj2);
IkReal x851=(cj2*x849);
IkReal x852=((1.0)*x848);
IkReal x853=(cj2*cj3*sj1);
CheckValue<IkReal> x854 = IKatan2WithCheck(IkReal(((((-1.0)*x846*x852))+((x846*x849))+(((-1.0)*cj1*x844*x845))+(((-1.0)*x847*x852))+((r22*x853))+((x847*x849)))),IkReal((((x848*x853))+(((-1.0)*sj1*x844*x851))+((r22*x847))+(((-1.0)*x844*x848*x850))+((cj3*x849*x850))+((sj1*x845)))),IKFAST_ATAN2_MAGTHRESH);
if(!x854.valid){
continue;
}
CheckValue<IkReal> x855=IKPowWithIntegerCheck(IKsign(((((-1.0)*x842*x843))+(r22*r22)+((x842*(r20*r20)))+(((-2.0)*x848*x849))+x843)),-1);
if(!x855.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x854.value)+(((1.5707963267949)*(x855.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x856=IKsin(j4);
IkReal x857=IKcos(j4);
IkReal x858=(r12*sj0);
IkReal x859=(r01*sj5);
IkReal x860=(cj0*r02);
IkReal x861=(cj1*cj2);
IkReal x862=(cj3*sj1);
IkReal x863=((1.0)*sj2);
IkReal x864=(r02*sj0);
IkReal x865=(cj5*r10);
IkReal x866=(cj0*r00);
IkReal x867=(r11*sj5);
IkReal x868=(r21*sj5);
IkReal x869=(r00*sj0);
IkReal x870=((1.0)*x856);
IkReal x871=(cj5*x856);
IkReal x872=(cj0*x856);
IkReal x873=((1.0)*x857);
IkReal x874=(cj5*x857);
IkReal x875=(cj0*x873);
evalcond[0]=((((-1.0)*x868*x870))+(((-1.0)*x861))+(((-1.0)*sj1*x863))+((r22*x857))+((r20*x871)));
evalcond[1]=(((cj2*x862))+(((-1.0)*x868*x873))+(((-1.0)*cj1*cj3*x863))+((r20*x874))+(((-1.0)*r22*x870)));
evalcond[2]=((((-1.0)*r12*x875))+((x867*x872))+(((-1.0)*cj0*x865*x870))+((x869*x871))+(((-1.0)*sj0*x859*x870))+((x857*x864)));
evalcond[3]=((((-1.0)*sj3))+((cj0*x857*x867))+((r12*x872))+(((-1.0)*x864*x870))+((x869*x874))+(((-1.0)*sj0*x859*x873))+(((-1.0)*x865*x875)));
evalcond[4]=(((cj2*sj1))+(((-1.0)*cj0*x859*x870))+((sj0*x856*x865))+((x866*x871))+(((-1.0)*cj1*x863))+(((-1.0)*sj0*x867*x870))+((x857*x858))+((x857*x860)));
evalcond[5]=(((sj2*x862))+((cj3*x861))+(((-1.0)*x860*x870))+((x866*x874))+((sj0*x857*x865))+(((-1.0)*sj0*x867*x873))+(((-1.0)*x858*x870))+(((-1.0)*x859*x875)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x876=(cj1*cj2);
IkReal x877=(cj5*sj0);
IkReal x878=(sj1*sj2);
IkReal x879=(cj0*r12);
IkReal x880=(cj0*cj5);
IkReal x881=((1.0)*r10);
IkReal x882=(sj0*sj5);
IkReal x883=((1.0)*r01);
IkReal x884=(cj0*r11*sj5);
IkReal x885=((1.0)*r02*sj0);
CheckValue<IkReal> x886 = IKatan2WithCheck(IkReal((((x876*x879))+((x878*x879))+(((-1.0)*x876*x885))+(((-1.0)*x878*x885)))),IkReal(((((-1.0)*x878*x882*x883))+((x876*x884))+(((-1.0)*x878*x880*x881))+((r00*x877*x878))+(((-1.0)*x876*x880*x881))+((x878*x884))+((r00*x876*x877))+(((-1.0)*x876*x882*x883)))),IKFAST_ATAN2_MAGTHRESH);
if(!x886.valid){
continue;
}
CheckValue<IkReal> x887=IKPowWithIntegerCheck(IKsign((((r11*x877))+((r10*x882))+((r01*x880))+((cj0*r00*sj5)))),-1);
if(!x887.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x886.value)+(((1.5707963267949)*(x887.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x888=IKsin(j4);
IkReal x889=IKcos(j4);
IkReal x890=(r12*sj0);
IkReal x891=(r01*sj5);
IkReal x892=(cj0*r02);
IkReal x893=(cj1*cj2);
IkReal x894=(cj3*sj1);
IkReal x895=((1.0)*sj2);
IkReal x896=(r02*sj0);
IkReal x897=(cj5*r10);
IkReal x898=(cj0*r00);
IkReal x899=(r11*sj5);
IkReal x900=(r21*sj5);
IkReal x901=(r00*sj0);
IkReal x902=((1.0)*x888);
IkReal x903=(cj5*x888);
IkReal x904=(cj0*x888);
IkReal x905=((1.0)*x889);
IkReal x906=(cj5*x889);
IkReal x907=(cj0*x905);
evalcond[0]=((((-1.0)*x900*x902))+((r20*x903))+(((-1.0)*x893))+((r22*x889))+(((-1.0)*sj1*x895)));
evalcond[1]=((((-1.0)*x900*x905))+((cj2*x894))+(((-1.0)*r22*x902))+((r20*x906))+(((-1.0)*cj1*cj3*x895)));
evalcond[2]=((((-1.0)*cj0*x897*x902))+((x901*x903))+(((-1.0)*r12*x907))+((x899*x904))+((x889*x896))+(((-1.0)*sj0*x891*x902)));
evalcond[3]=((((-1.0)*x896*x902))+(((-1.0)*sj3))+(((-1.0)*x897*x907))+((x901*x906))+((r12*x904))+(((-1.0)*sj0*x891*x905))+((cj0*x889*x899)));
evalcond[4]=(((cj2*sj1))+((sj0*x888*x897))+((x889*x890))+((x889*x892))+(((-1.0)*sj0*x899*x902))+(((-1.0)*cj0*x891*x902))+((x898*x903))+(((-1.0)*cj1*x895)));
evalcond[5]=((((-1.0)*x891*x907))+(((-1.0)*x890*x902))+((cj3*x893))+((sj0*x889*x897))+((sj2*x894))+(((-1.0)*x892*x902))+(((-1.0)*sj0*x899*x905))+((x898*x906)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - lwa4p (7fb40e05f8f82ae021231f8bbfedf57b)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
